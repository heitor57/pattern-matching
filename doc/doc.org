#+TITLE: Algoritmos e Estrutura de Dados III (2019-1)
#+SUBTITLE: Trabalho Prático 4
#+AUTHOR: Heitor Lourenço Werneck
#+EMAIL: heitorwerneck@hotmail.com
#+DATE:1 de Julho de 2019
#+LANGUAGE: pt
#+OPTIONS: ^:nil email:nil author:nil toc:nil
#+LATEX_HEADER: \author{Heitor Lourenço Werneck \\{\href{mailto:heitorwerneck@hotmail.com}{heitorwerneck@hotmail.com}}}
#+LATEX_HEADER: \usepackage[AUTO]{babel}
# mathtools ja inclui amsmath #+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage[binary-units=true]{siunitx}
#+LATEX_HEADER: \usepackage[top=0.5cm,bottom=1.5cm,left=2cm,right=2cm]{geometry}

#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage[noend]{algpseudocode}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{colortbl}
#+LATEX_HEADER: \usepackage{graphicx,wrapfig,lipsum}
#+LATEX_HEADER: \RequirePackage{fancyvrb}
#+LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\small}
#+LATEX_HEADER: \usepackage[font=small,labelfont=bf]{caption} % Required for specifying captions to tables and figures
#+LATEX_HEADER: \usepackage[subrefformat=parens]{subcaption}
#+latex_class_options: [11pt]

#+PROPERTY: header-args :eval never-export
#+begin_export latex
\usetikzlibrary{arrows, fit, matrix, positioning, shapes, backgrounds,intersections}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{automata, positioning, arrows}
\usetikzlibrary{calc}
\newcommand{\ccb}{\cellcolor{blue}}
\newcommand{\ccc}{\cellcolor{gray}}
\newcommand{\ccr}{\cellcolor{red}}
\newcommand{\ccg}{\cellcolor{green}}
\newcommand{\ccbl}{\cellcolor{black}}
\newcommand{\cco}{\cellcolor{orange}}
#+end_export


#+begin_export latex
\newcommand{\algruledefaultfactor}{.75}
\newcommand{\algstrut}[1][\algruledefaultfactor]{\vrule width 0pt
depth .25\baselineskip height #1\baselineskip\relax}
\newcommand*{\algrule}[1][\algorithmicindent]{\hspace*{.5em}\vrule\algstrut
\hspace*{\dimexpr#1-.5em}}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\makeatletter
\newcount\ALG@printindent@tempcnta
\def\ALG@printindent{%
    \ifnum \theALG@nested>0% is there anything to print
    \ifx\ALG@text\ALG@x@notext% is this an end group without any text?
    % do nothing
    \else
    \unskip
    % draw a rule for each indent level
    \ALG@printindent@tempcnta=1
    \loop
    \algrule[\csname ALG@ind@\the\ALG@printindent@tempcnta\endcsname]%
    \advance \ALG@printindent@tempcnta 1
    \ifnum \ALG@printindent@tempcnta<\numexpr\theALG@nested+1\relax% can't do <=, so add one to RHS and use < instead
    \repeat
    \fi
    \fi
}%

\patchcmd{\ALG@doentity}{\noindent\hskip\ALG@tlm}{\ALG@printindent}{}{\errmessage{failed to patch}}

\AtBeginEnvironment{algorithmic}{\lineskip0pt}

\newcommand*\Let[2]{\State #1 $\gets$ #2}
\newcommand*\Stateh{\State \algstrut[1]}

\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
  \State \algorithmicif\ #1\ \algorithmicthen\ #2\ \algorithmicelse\ #3}
\algnewcommand{\Break}[0]{\textbf{break}}
#+end_export
#+BEGIN_EXPORT latex
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\renewcommand{\listalgorithmname}{Lista de\ALG@name s}
\makeatother
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}
\tikzstyle{block} = [rectangle, draw, 
    text width=5em, text centered]
\tikzstyle{elli} = [draw,ellipse,text width=5em,text centered]
\tikzstyle{decision} = [diamond, draw,text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{line} = [draw, -latex',dashed]

\newcommand{\myDistance}{2.8cm}
\AtBeginEnvironment{algorithmic}{\footnotesize}
#+END_EXPORT
* Introdução

  O trabalho a ser apresentado consiste em desenvolver algoritmos de busca de padrão, exato e aproximado, avaliando o desempenho dos mesmos em diversos ambientes. A busca de padrão é formalizada do seguinte modo: Há um texto $T[1..n]$ de largura $n$ e o padrão é $P[1..m]$ de largura $m\leq n$. Também é assumido que os elementos de $P$ e $T$ tem como fonte de seus caracteres um dicionário $\Sigma$ finito. O padrão $P$ ocorre em $T$ na posição $x$ do texto se $1\leq x \leq n-m+1$ e $T[x..x+m-1]=P[1..m]$. Um texto vazio é denotado por $\varepsilon$. cite:cormen09_introd
  
  Busca de padrão é usada em busca por sequencias de DNA, análise de registro de sistemas de informação e também esta muito presente a utilização por usuários de computadores em buscas de texto na Internet.

  Os algoritmos desenvolvidos para solução do problema foram: Boyer Moore Horspool (BMH); BMH Sunday (BMHS); Shift-And; Shift-And aproximado; BMHS paralelo.

* Estrutura de dados
Para o armazenamento do texto e padrão foi suposto que o texto de entrada será ASCII, logo foi criado o tipo /CharType/ que é o tipo primitivo /unsigned char/ da linguagem C que é usado para guardar tanto o texto quanto o padrão.
#+BEGIN_SRC C
typedef unsigned char CharType;
#+END_SRC

Também é importante notar que o tipo definido suporta somente um número constante de caracteres que varia de arquitetura para arquitetura. Como definido anteriormente, o dicionário possui um número finito de elementos.
Logo é definido o Tamanho do alfabeto como:

#+BEGIN_EXPORT latex
\begin{equation}
ALPHABETSIZE = |\Sigma| \coloneqq 256 = 2^{(sizeof(CharType)\cdot 8)}
\end{equation}
#+END_EXPORT

Outra estrutura criada que auxilia no ShiftAnd é o /bitVector/ que possui a seguinte definição: cite:bitarrayclibrary

#+BEGIN_SRC C
typedef unsigned char WordType;
struct bitVector{
  size_t bits;
  WordType *vector;
};
#+END_SRC

Sendo =size_t bits= o número de bits utilizado pelo =WordType *vector= e =WordType *vector= a lista de bits por si.

Essa estrutura de dados é representada na figura ref:fig:bitv.

#+BEGIN_EXPORT latex
\begin{figure}
\begin{center}
\begin{tikzpicture}
\node (a) at (0,0){
  \begin{tabular}{ | l | c | c | c | c | c | c | r |}
    \hline
    MSB & & ...& & LSB\\ \hline
  \end{tabular}
};
\node[xshift=1.95cm] (b) at (a.east){
  \begin{tabular}{ | l | c | c | c | c | c | c | r |}
    \hline
    MSB & & ...& & LSB\\ \hline
  \end{tabular}
};
\node[xshift=0.20cm] (c) at (b.east){...};

\draw[decorate,decoration={brace, amplitude=10pt, raise=5pt, mirror}]
  (a.south west) to node[black,midway,below= 15pt] {$\beta =$ sizeof(WordType)$\cdot$ 8} (a.south east);

\draw[->,yshift=0.2cm,xshift=-2.3cm,line width=0.3mm,left of = a,xshift=1cm,yshift=0.27cm] (0,0) -- (9,0) node[anchor=south east] {Crescimento da lista de bits};

\draw[->,line width=0.3mm,left of = a,xshift=-3cm] (0,0) -- (1,0) node[anchor=south east] {Primeiro bit};

\end{tikzpicture}
\end{center}
\caption{Vetor de bits.(''MSB'': Bit mais significativo; ''LSB'': bit menos significativo.)}\label{fig:bitv}
\end{figure}
#+END_EXPORT

Todas operações binárias necessárias para o Shift-And foram implementadas. Ou seja: ou(|); e(&); deslocamento para a direita($>>$). Também outras funções foram implementadas para operar bit a bit: uma para definir como 1 o enésimo bit, outra para definir como 0 o enésimo bit e também mais uma para checar o enésimo bit.

#+BEGIN_SRC C
bitVector* bVSetBit(bitVector* bitv,size_t bit);// Define como 1 enésimo bit
bitVector* bVClearBit(bitVector* bitv,size_t bit);// Define como 0 enésimo bit
bitVector* bVOr(bitVector* dest,bitVector* src1,bitVector* src2);// Operação logica ou
bitVector* bVAnd(bitVector* dest,bitVector* src1,bitVector* src2);// Operação logica e
bitVector* bVClearAll(bitVector* target);// Define como 0 todo o vetor de bits
bitVector* bVShiftLeft(bitVector* dest,bitVector* src,size_t shifts);// Deslocamento para esquerda
bitVector* bVShiftRight(bitVector* dest,bitVector* src,size_t shifts);// Deslocamento para a direita
int bVIsSetBit(bitVector* target,size_t bit);// Define como 1 enésimo bit
#+END_SRC

* Solução

** Boyer Moore Horspool

Booyer Moore Horspool(BMH) é um algoritmo de casamento exato de padrão que compara um padrão da direita para a esquerda e passa pelo texto da esquerda para a direita. 

O preprocessamento necessário para o algoritmo é a criação de uma tabela que indica o deslocamento que poderá ser realizado. Quando comparado um caractere do texto ao do padrão, se for diferente ou haver um casamento irá haver um deslocamento de acordo com o caractere no texto correspondente ao ultimo caractere do padrão. A construção da tabela de deslocamento se da pelo modelo apresentado na equação ref:eq:dbmh.

#+BEGIN_EXPORT latex
\begin{equation}
d[x]=min\{ j \text{ tal que } j =m | (1 \leq j < m \& P[m-j]=x))
\label{eq:dbmh}
\end{equation}
#+END_EXPORT

 O algoritmo ref:alg:bmh descreve o comportamento detalhadamente.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} $T[0..n-1], n, P[0..m-1], m, match[0..n-1]$
\textbf{Output:} $match[0..n-1]$
\caption{Boyer Moore Horspool.}\label{alg:bmh}
\begin{algorithmic}[1]
\Procedure{preProcessBMH}{$d,P,m$}
\For{$i=0$ to $ALPHABETSIZE-1$}
\State $d[i]\gets m$
\EndFor
\For{$i=0$ to $m-2$}
\State $d[P[i]]\gets m-i-1$
\EndFor
\EndProcedure
\Procedure{BMH}{$T,n,P,m,match$}
\State $match\gets \{0,...,0\}$
\State preProcessBMH($d,P,m$)
\State $i\gets m$
\While{$i\leq n$}
\State $base\gets i$
\State $j\gets m$
\While{$j>0 \land T[base-1] = P[j-1]$}
\State $j\gets j-1; base\gets base -1$
\EndWhile
\If{$j=0$}
\State $match[base]\gets true$
\EndIf
\State $i\gets i+d[T[i-1]]$
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

** Boyer Moore Horspool Sunday

   O Boyer Moore Horspool Sunday(BMHS) é um algoritmo também de casamento exato de padrão. O algoritmo é bem similar ao BMH, porém apresenta algumas variantes. O BMHS usa uma abordagem diferente para o modelo de deslocamento. O endereçamento a tabela e dado pelo caractere no texto correspondente ao caractere após o último caractere do padrão. O modelo da tabela de deslocamento é a equação ref:eq:dbmhs.

#+BEGIN_EXPORT latex
\begin{equation}
d[x]=min\{ j \text{ tal que } j =m | (1 \leq j \leq m \& P[m+1-j]=x))
\label{eq:dbmhs}
\end{equation}
#+END_EXPORT

O algoritmo ref:alg:bmhs descreve o comportamento do BMHS detalhadamente.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} $T[0..n-1], n, P[0..m-1], m, match[0..n-1]$
\textbf{Output:} $match[0..n-1]$
\caption{Boyer Moore Horspool Sunday.}\label{alg:bmhs}
\begin{algorithmic}[1]
\Procedure{preProcessBMHS}{$d,P,m$}
\For{$i=0$ to $ALPHABETSIZE-1$}
\State $d[i]\gets m+1$
\EndFor
\For{$i=0$ to $m-1$}
\State $d[P[i]]\gets m-i$
\EndFor
\EndProcedure
\Procedure{BMHS}{$T,n,P,m,match$}
\State preProcessBMHS($d,P,m$)
\State $i\gets m$
\While{$i\leq n$}
\State $base\gets i$
\State $j\gets m$
\While{$j>0 \land T[base-1] = P[j-1]$}
\State $j\gets j-1; base\gets base -1$
\EndWhile
\If{$j=0$}
\State $match[base]\gets true$
\EndIf
\If{$i<n$}
\State $i\gets i+d[T[i]]$
\Else
\State \Break
\EndIf
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

** Shift-And

O Shift-And é um algoritmo que explora operações que tiram proveito do tamanho da palavra da arquitetura utilizada, com isso consegue um paralelismo assim reduzindo o numero de operações que o algoritmo realiza em até um fator de $\beta$. O Shift-And pode ser visto como uma simulação de um autômato não determinista que pesquisa pelo padrão no texto.

A modelagem do problema foi feita de um modo generalista, ou seja, para resolver o problema de casamento aproximado. O casamento exato é uma especificação desse problema e pode ser resolvido com um erro definido como zero. Ou seja, algoritmo exato: ShiftAnd$(T,n,P,m,0)$.(algoritmo ref:alg:shiftand)

Um exemplo de autômato para casamento aproximado é mostrado na figura ref:fig:automato1. 

Um caractere quando é casado é representado pela aresta horizontal, a aresta vertical insere um caractere no padrão($R_{j-1}$), a aresta diagonal continua substitui um caractere($R_{j-1}>>1$) e a aresta diagonal tracejada remove($R^{'}_{j-1}>>1$).

Cada linha j ($0<j\leq error$) do autômato representa um erro diferente, então o algoritmo ShiftAnd reúne essas linhas em uma palavra $R_{j}$. Os vetores de bits $R[0..error]$ são atualizados a cada caractere lido do texto e a simulação do autômato é feita através de operações em bits. 

Para simular esse autômato o Shift-And começa criando uma máscara de bits para cada palavra do alfabeto e quando um caractere é encontrado na enésima posição do texto é também definido como 1 na enésima posição da máscara de bits do carácter. É importante notar que as operações no vetor de bits dependem de como o vetor de bits é definido, a imagem ref:fig:bitv ilustra o modelo de vetor de bits utilizado nesse trabalho.

O seguinte modelo descreve o comportamento que deve ocorrer para realizar os casamentos a cada caractere na posição $i$ do texto:(equação ref:eq:shiftand)

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
R^{'}_{0}=((R_{0}>>1)|1)\&mask[T[i]]\\
R^{'}_{j}=(R_{j}>>1)\&mask[T[i]]|R_{j-1}|(R_{j-1}>>1)|(R^{'}_{j-1}>>1)\\
\end{aligned}\label{eq:shiftand}
\end{equation}
#+END_EXPORT

Com a máscara definida é possível verificar os casamentos que vão ocorrendo no texto. O algoritmo ref:alg:shiftand descreve o comportamento detalhadamente.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} $T[0..n-1], n, P[0..m-1], m, match[0..n-1], error$
\textbf{Output:} $match[0..n-1]$
\caption{Shift-And.}\label{alg:shiftand}
\begin{algorithmic}[1]
\Procedure{ShiftAnd}{$T,n,P,m,match,error$}
\State $R1\gets 1$
\State $mask[0..ALPHABETSIZE-1]\gets \{0,...,0\},R[error+1]\gets \{0,...,0\}$
\For{$i=0$ to $m-1$}
\State $SetBit(mask[P[i]],i)$
\EndFor
\State $ClearAll(R[0]); aux \gets bitVectorNew(m)$
\For{$i=1$ to $error$}
\State $R[i]\gets R[i-1]$
\State $SetBit(R[i],i-1)$
\EndFor
\For{$i=0$ to $n-1$}
\State $Rprevious\gets R[0]$
\State $Rnew\gets$ $((Rprevious>>1)|R1)$ \&  $mask[T[i]]$
\State $R[0]\gets Rnew$
\For{$j=1$ to $error$}
\State $Rnew\gets ((R[j]>>1) \& mask[T[i]]) | Rprevious | Rprevious>>1 | Rnew>>1$
\State $Rprevious\gets R[j]$
\State $R[j]\gets Rnew|R1$
\EndFor
\If{$IsSetBit(Rnew,m-1) \land (n>i+1-m) \land (i+1-m \geq 0)$}
\State $match[i+1-m]\gets true$
\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{figure}
\begin{center}
\begin{tikzpicture}[auto,node distance=1.8cm,thick]
\node[state, initial,initial text=] (0) {0};
\node[state,right of=0] (1) {1};
\node[state,right of=1] (2) {2};
\node[state,right of=2] (3) {3};
\node[state,right of=3] (4) {4};
\node[state,right of=4,accepting] (5) {5};
\node[state,below of=0] (0') {0};
\node[state,right of=0'] (1') {1};
\node[state,right of=1'] (2') {2};
\node[state,right of=2'] (3') {3};
\node[state,right of=3'] (4') {4};
\node[state,right of=4',accepting] (5') {5};
\draw (0) edge[loop above,->] node{$\Sigma$} (0)
(0) edge[above,->] node{t} (1)
(1) edge[above,->] node{e} (2)
(2) edge[above,->] node{x} (3)
(3) edge[above,->] node{t} (4)
(4) edge[above,->] node{o} (5)
(0') edge[above,->] node{t} (1')
(1') edge[above,->] node{e} (2')
(2') edge[above,->] node{x} (3')
(3') edge[above,->] node{t} (4')
(4') edge[above,->] node{o} (5')
(0) edge[->] node{$\Sigma$} (0')
(1) edge[->] node{$\Sigma$} (1')
(2) edge[->] node{$\Sigma$} (2')
(3) edge[->] node{$\Sigma$} (3')
(4) edge[->] node{$\Sigma$} (4')
(5) edge[->] node{$\Sigma$} (5')
(0) edge[above,bend left=25,->,dashed] node{$\varepsilon$} (1')
(1) edge[above,bend left=25,->,dashed] node{$\varepsilon$} (2')
(2) edge[above,bend left=25,->,dashed] node{$\varepsilon$} (3')
(3) edge[above,bend left=25,->,dashed] node{$\varepsilon$} (4')
(4) edge[above,bend left=25,->,dashed] node{$\varepsilon$} (5')
(0) edge[above,bend right=5,->] node{$\Sigma$} (1')
(1) edge[above,bend right=5,->] node{$\Sigma$} (2')
(2) edge[above,bend right=5,->] node{$\Sigma$} (3')
(3) edge[above,bend right=5,->] node{$\Sigma$} (4')
(4) edge[above,bend right=5,->] node{$\Sigma$} (5');
\end{tikzpicture}
\end{center}
\caption{Autômato de busca com erro 1.}\label{fig:automato1}
\end{figure}
#+END_EXPORT

** BMHS Paralelo
   Algumas definições iniciais são necessárias para analisar o problema de paralelizar o BMHS. Seja $p$ o número de processadores, $P_i$ o processador $i$, $0\leq i < p$, *for all* .. *end for* ativa conjunto de processadores, $n$ o tamanho do texto como já definido.

Para separar o problema do texto em partes é possível usar a seguinte formula para dividir o problema:
#+BEGIN_EXPORT latex
\begin{equation}
\alpha (i)=\text{Começo}(i) = \floor*{\frac{i\cdot n}{p}};\text{Fim}(i) = \floor*{\frac{(i+1)\cdot n}{p}}
\end{equation}
#+END_EXPORT

Esse tipo de divisão do texto não trata o caso que o padrão esta entre um bloco de texto e outro. Para tratar isso a formula do fim pode ser redefinida adicionando uma soma do tamanho do padrão menos um, deste modo será possível sempre obter o padrão. (equação ref:eq:modelo2)

#+BEGIN_EXPORT latex
\begin{equation}
\omega (i)=\text{Fim}(i) = 
\begin{cases} 
\floor*{\frac{(i+1)\cdot n}{p}}-1+m &\text{se } i<p-1\\
\\
\floor*{\frac{(i+1)\cdot n}{p}} &\text{se } i=p-1
\end{cases}
\label{eq:modelo2}
\end{equation}
#+END_EXPORT

Essa formula define o começo e fim da busca para o BMHS. A posição real no texto T[0..n-1] é dada como: Começo $= \alpha (i)$ e Fim  $= \omega (i)-1$. A figura ref:fig:exemploparalelo exemplifica a divisão de blocos realizada.

#+BEGIN_EXPORT latex
\begin{figure}
\begin{center}
\begin{tikzpicture}[auto,node distance=0.7cm]
\node (a) at (0,0){
  \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|r|}
    \hline
    o & i & o & l & a & h & e &l &l&o &y & o & h& o&l & a & '\textbackslash n ' \\ \hline
  \end{tabular}
};
\node (b)[below of= a] at (-3.6,0){
  \begin{tabular}{|l|c|c|c|c|r|}
    \hline
    o & i & \ccc o &\ccc l &\ccc a&h \\ \hline
  \end{tabular}
};

\node (c)[below of= b,xshift=2.35cm] {
  \begin{tabular}{|l|c|c|c|c|r|}
    \hline
    a & h & e & l & l & o  \\ \hline
  \end{tabular}
};

\node (d)[below of= c,xshift=2.48cm] {
  \begin{tabular}{|l|c|c|c|c|r|}
    \hline
    l & o & y & o & h & o  \\ \hline
  \end{tabular}
};

\node (e)[below of= d,xshift=2.37cm] {
  \begin{tabular}{|l|c|c|c|r|}
    \hline
    h &\ccc o & \ccc l & \ccc a & '\textbackslash n '  \\ \hline
  \end{tabular}
};
\end{tikzpicture}
\end{center}
\caption{Distribuição de dados pelos processadores com texto com n=17, p=4, P=ola.}\label{fig:exemploparalelo}
\end{figure}
#+END_EXPORT

Também é interessante caracterizar os blocos criados para paralelizar o algoritmo. O tamanho de cada bloco sem ser o ultimo é dado pela regra: $\floor{n/numThreads+m-1}$

logo o tamanho total de blocos é dado por: 
#+BEGIN_EXPORT latex
\begin{equation}
T(numThreads,n,m) = (numThreads-1)\cdot \floor*{\frac{n}{numThreads}+m-1}+n-\floor*{(numThreads-1)\cdot \frac{n}{numThreads}}
\end{equation}
#+END_EXPORT

Essa função de tamanho consegue mostrar o aumento de tamanho obtido por paralelizar o algoritmo. ($T(numThreads,n,m)/n$)

Antes da criação do algoritmo definitivamente é necessário definir um limite superior de divisão de blocos. Esse limite é dado por $\ceil{n/m}$ blocos pois a propriedade $m\leq n$ deve se manter para não ocorrer de um bloco menor que $m$ pois não há possibilidade de haver um casamento. Logo o número de threads máximo e necessário é $\ceil{n/m}$. Com toda essa base o algoritmo ref:alg:pbmh é definido.

#+BEGIN_EXPORT latex
\begin{algorithm}
\textbf{Input:} $T[0..n-1], n, P[0..m-1], m, match[0..n-1]$
\textbf{Output:} $match[0..n-1]$
\caption{BMHS Paralelo.}\label{alg:pbmh}
\begin{algorithmic}[1]
\Procedure{PBMHS}{}
\State preProcessBMHS($d,P,m$)
\If{$numThreads>\ceil{n/m}$}
\State $numThreads = \ceil{n/m}$
\EndIf
\For{\textbf{all} $P_{i}$, $0 \leq i < numThreads$}
\State $begin\gets \alpha(i)$
\State $end\gets \omega(i)$
\State PBMHSF($T,n,P,m,match,d,begin,end$)
\EndFor
\EndProcedure

\Procedure{PBMHSF}{$T,n,P,m,match,d,begin,end$}
\State $i\gets begin+m$
\While{$i\leq end$}
\State $base\gets i$
\State $j\gets m$
\While{$j>0 \land T[base-1] = P[j-1]$}
\State $j\gets j-1; base\gets base -1$
\EndWhile
\If{$j=0$}
\State $match[base]\gets true$
\EndIf
\If{$i<n$}
\State $i\gets i+d[T[i]]$
\Else
\State \Break
\EndIf
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

#+END_EXPORT

* Análise de complexidade
** Complexidade de tempo
*** BMH

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
\text{preProcessBMH} \in O(|\Sigma|+m)\\
\text{BMH} \in O(n\cdot m+|\Sigma|+m)
\end{aligned}
\end{equation}
#+END_EXPORT
Simplificando a complexidade do algoritmo é dada por: $O(n\cdot m)$. No melhor caso é $O(n/m)$ e o caso esperado é $O(n/m)$ cite:galil79_improv_worst_case_runnin_time, essas afirmações são compartilhadas pelo BMHS e BMHS Paralelo.

O pior caso desse algoritmo se expressa no exemplo dado na figura ref:fig:exemplobmh.

#+BEGIN_EXPORT latex
\begin{figure}
\centering
\begin{BVerbatim}
  T:aaaaaaaa
  P:aaaa
     aaaa
      aaaa
       aaaa
	aaaa
\end{BVerbatim}
\caption{Exemplo de execução BMH.}\label{fig:exemplobmh}
\end{figure}
#+END_EXPORT


*** BMHS
#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
\text{preProcessBMHS} \in O(|\Sigma|+m)\\
\text{BMHS} \in O(n\cdot m+|\Sigma|+m)\\
\text{BMHS} \in O(n\cdot m)
\end{aligned}
\end{equation}
#+END_EXPORT

*** Shift-And
    Para analisar a complexidade de tempo do ShiftAnd é necessário analisar a complexidade das operações binárias criadas para auxiliar. Seja $bits$ o número de bits alocado para o vetor de bits, $shifts$ é a quantidade de deslocamentos a serem realizados e $\beta = sizeof(WordType)\cdot 8$ como definido na figura ref:fig:bitv.
#+ATTR_LATEX: :mode math :environment array
|----------+------------+-----------------------+-----------------------+-----------------------+-----------------------------------+-----------------------------------+------------|
| bVSetBit | bVClearBit | bVOr                  | bVAnd                 | bVClearAll            | bVShiftLeft                       | bVShiftRight                      | bVIsSetBit |
|----------+------------+-----------------------+-----------------------+-----------------------+-----------------------------------+-----------------------------------+------------|
| O(1)     | O(1)       | O(\frac{bits}{\beta}) | O(\frac{bits}{\beta}) | O(\frac{bits}{\beta}) | O(\frac{shifts\cdot bits}{\beta}) | O(\frac{shifts\cdot bits}{\beta}) | O(1)       |

Para simplificar essa tabela somente com os termos necessários os termos constantes podem ser removidos, o termo \beta é uma constante logo pode ser removido, o shifts também tem um limite pois no máximo o deslocamento é do tamanho da palavra e nenhum comportamento diferente ocorre além disso logo a tabela pode ser reescrita como:

|----------+------------+---------+---------+------------+-------------+--------------+------------|
| bVSetBit | bVClearBit | bVOr    | bVAnd   | bVClearAll | bVShiftLeft | bVShiftRight | bVIsSetBit |
|----------+------------+---------+---------+------------+-------------+--------------+------------|
| O(1)     | O(1)       | O(bits) | O(bits) | O(bits)    | O(bits)     | O(bits)      | O(1)       |

O custo para inicializar as máscaras com 0 é $O(|\Sigma|)$. O custo para inicializar os R's é $O(error)$. No caso $bits = m$ logo a complexidade do ShiftAnd será:

#+BEGIN_EXPORT latex
\begin{equation}
\begin{aligned}
O(m\cdot (|\Sigma|+error+ n\cdot (error+1)))\\
\text{ShiftAnd} \in O(m\cdot (|\Sigma|+ n\cdot (error+1)+error))\\
\text{ShiftAnd} \in O(m\cdot n\cdot error)
\end{aligned}
\end{equation}
#+END_EXPORT

Com um $m$ menor que $\beta$ ou pelo menos mantendo-se relativamente pequeno o algoritmo irá apresentar complexidade $O(|\Sigma|+ n\cdot (error+1))$.

*** BMHS Paralelo
A complexidade da criação das numThreads threads é $O(numThreads)$ ou $O(p)$. Sendo thread uma tarefa que um programa executa.

A complexidade é simplesmente $PBMHS \in O(m\cdot n/p+p)$ pois o trabalho é distribuído para $p$ processadores que conseguem trabalhar simultaneamente no problema.


** Complexidade de espaço

*** BMH
O algoritmo BMH somente aloca uma tabela de deslocamento com complexidade de espaço $O(|\Sigma|)$. Logo sua complexidade é $O(|\Sigma|)$.

*** BMHS
O BMHS utiliza somente uma tabela de deslocamento assim como o BMH, sua complexidade de espaço é $O(|\Sigma|)$.

*** Shift-And
O ShiftAnd usa um vetor de máscara de bits que tem custo de espaço de $O(m\cdot |\Sigma|)$ pois cada máscara para cada caractere deve ser do tamanho do padrão. Também é utilizado um vetor de vetor de bits para guardar os resultados do processo de casamento, esse vetor cresce de acordo com o número de erros permitidos no padrão logo sua complexidade de espaço é $O(m\cdot error)$. Logo a complexidade de espaço do ShiftAnd é $O(m\cdot (|\Sigma|+error))$.

*** BMHS Paralelo

O BMHS paralelo utiliza uma tabela de deslocamento com complexidade de espaço $O(|\Sigma|)$, também necessita guardar as threads criadas, logo a complexidade do algoritmo será $PBMHS \in O(|\Sigma|+p)$.

** Análise geral
   A tabela [[tab:complexidade]] mostra todas complexidades obtidas. Em uma análise de contexto geral a complexidade de espaço será pelo menos $O(n+m)$ que é o tamanho do texto e do padrão. Como o texto e padrão nos algoritmos são somente uma referência para um vetor não há alocação dinâmica de vetor logo a complexidade de espaço dentro das funções é constante em relação a esse caso.

   #+CAPTION: Complexidades.
   #+NAME: tab:complexidade
   |--------------+--------------------------------------------------------+------------------------------------|
   | Complexidade | Tempo                                                  | Espaço                             |
   |--------------+--------------------------------------------------------+------------------------------------|
   | BMH          | $O(n\cdot m+\vert\Sigma\vert+m)$                       | O(\vert\Sigma\vert)                |
   | BMHS         | $O(n\cdot m+\vert\Sigma\vert+m)$                       | O(\vert\Sigma\vert)                |
   | ShiftAnd     | $O(m\cdot (\vert\Sigma\vert+ n\cdot (error+1)+error))$ | O(m\cdot (\vert\Sigma\vert+error)) |
   | PBMHS        | $O(\frac{m\cdot n}{p}+p)$                              | O(\vert\Sigma\vert+p)              |
   |--------------+--------------------------------------------------------+------------------------------------|

* Resultados
A máquina utilizada para os experimentos possui as seguintes especificações: Intel(R) Core(TM) i3-4005U CPU @ 1.70GHz e 4GiB de memória RAM.

Para fazer a análise de resultados foi utilizado um banco de dados de genomas cite:genomelist.

A tabela ref:tab:bases mostra todas bases utilizadas nos experimentos. A base \iota é padrão para a análise do tempo e a base \zeta para a análise de espaço. A base A é feita somente do caractere a.

O $\beta$ na arquitetura utilizada foi de 64. Em gráficos com o Shift-And aproximado junto com outros algoritmos por padrão o erro é 2. Em gráficos onde o $m$ não é variável é utilizado como padrão $m=30$.

Para análise de tempo do algoritmo paralelo foi primeiro observado a relação de tempo de usuário, tempo de sistema e tempo real. O tempo de usuário mais o tempo de sistema dividido pelo número de processadores deu resultado similar ao tempo real, em uma condição onde o computador foi utilizado majoritariamente somente pelos algoritmos aqui apresentados, logo foi utilizado o tempo total dividido pelo número de processadores.

#+CAPTION: Bases para criação de resultados.cite:genomelist
#+NAME: tab:bases
|-------------------------------------+------------+-----------|
| Base                                | Abreviação |         n |
|-------------------------------------+------------+-----------|
| Drosophila grimshawi strain (195MB) | \mu        | 204854690 |
| Anopheles koliensis (149MB)         | \lambda    | 156699065 |
| Caenorhabditis elegans (97MB)       | \kappa     | 101540352 |
| Marssonina coronariae (49MB)        | \iota      |  50949113 |
| Salmonella enterica (5MB)           | \theta     |   5198187 |
| Enterococcus faecalis (3MB)         | \eta       |   3402262 |
| Chlamydia gallinacea (1MB)          | \zeta      |   1080685 |
| A                                   | A          |   1000000 |
|-------------------------------------+------------+-----------|

** Tempo

Os fatores que influenciam no tempo de execução são conhecidos, isto é, o tamanho e conteúdo do texto; tamanho e conteúdo do padrão; número de erros para casamento aproximado; número de processadores para algoritmo paralelo. Primeiro será analisado a influência do tamanho do padrão nos algoritmos.

*** Tamanho do padrão (m)
É possivel observar que o comportamento do ShiftAnd é constante para $m\leq \beta$ na figura ref:fig:mxtimewordbound. Já o BMH, BMHS e BMHS Paralelo variam com o tamanho de m, como o caso esperado é $O(n/m)$ é possível entender a decaída de tempo de acordo com o aumento de $m$, observe como na figura ref:fig:mxtimenoboundb o tempo decai exatamente como foi discutido o caso esperado. Na figura ref:fig:mxtimenobound é mostrado $m\geq 1$, pode ser visto que o ShiftAnd possui um salto, esse salto é devido ao fato do algoritmo utilizado para $m>\beta$ possuir um /overhead/ da biblioteca de manipulação de bits. E a partir de \beta em \beta o tempo do algoritmo aumenta ($Tempo(\ceil*{\frac{m}{\beta}})$), pode ser observado que em certos intervalos de $m$ o tempo se mantém para $m$ diferentes o que é esperado.

Porém é necessário analisar o pior caso do algoritmo, esse caso é o caso que é necessário fazer o máximo de comparações possíveis, e pode ser criado assim como foi visto na seção de análise de complexidade. Os resultados no pior caso utilizando a base A são mostrados na figura ref:fig:mxtimeworstg. A diferença entre o caso com entradas de padrão casuais e uma forçando o pior caso é enorme, no pior caso o BMH, BMHS e BMHS Paralelo são piores que o Shift-And exato. O Shift-And aproximado ainda consegue ficar bem próximo do BMHS Paralelo para $m\geq \beta$. 

Com as regressões e de acordo com o $R^2$ elevado a complexidade na questão de $m$ foi comprovada.


#+begin_export latex
\begin{center}
\begin{figure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics[width=4.5cm]{mxtimewordbound}
\caption{$m\leq \beta$.}\label{fig:mxtimewordbound}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics[width=4.5cm]{mxtimenobound}
\caption{m sem limite.}\label{fig:mxtimenobound}
\end{subfigure}
\caption{Tempo de acordo com tamanho do padrão na base $\iota$.}
\end{figure}
\end{center}

\begin{wrapfigure}{R}{5.5cm}
\caption{Base $\iota$.}\label{fig:mxtimenoboundb}
\includegraphics[width=5.5cm]{mxtimenoboundb}
\end{wrapfigure} 

\begin{center}
\begin{figure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics[width=4.5cm]{mxtimewordboundworst}
\caption{$m\leq \beta$.}\label{fig:mxtimewordboundworst}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics[width=4.5cm]{mxtimenoboundworst}
\caption{m sem limite.}\label{fig:mxtimenoboundworst}
\end{subfigure}
\caption{Tempo de acordo com tamanho do padrão na base A, pior caso.}\label{fig:mxtimeworstg}
\end{figure}
\end{center}

#+end_export

*** Tamanho do texto (n)
O próximo passo é analisar e comprovar a influência do tamanho do texto $T$ nos algoritmos.

A figura ref:fig:nxtime mostra o crescimento do tempo de acordo com o tamanho do arquivo. O gráfico mostra que há um crescimento linear do tempo de acordo com o tamanho do arquivo para todos algoritmos, assim comprovando uma parte da complexidade obtida.

A figura ref:fig:nxcomp mostra o crescimento das comparações. Os números de comparações formam um gráfico similar ao gráfico com tempo, assim reforçando que o gráfico obtido com tempo é correto. Esses gráficos reforçam a inferioridade do Shift-And para casos médios, basta observar a diferença do número de comparações de qualquer um dos outros algoritmos.



#+begin_export latex
\begin{figure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics[width=7.5cm]{nxtime}
\caption{}\label{fig:nxtime}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\includegraphics[width=7.5cm]{nxcomp}
\caption{}\label{fig:nxcomp}
\end{subfigure}
\caption{Variação de n com todas bases exceto A e m=30.}\label{fig:nxg}
\end{figure}
#+end_export

*** Erro(error)
Agora é necessário avaliar o impacto do número de erros no tempo de execução. A figura ref:fig:errorxtime mostra o comportamento, o tempo cresce linearmente como previsto logo foi comprovado o termo de erro na complexidade tempo do algoritmo ShiftAnd.

#+BEGIN_EXPORT latex
\begin{wrapfigure}{R}{4.3cm}
\caption{m=30,base=$\iota$,Shift-And aproximado}\label{fig:errorxtime}
\includegraphics[width=4.3cm]{errorxtime}
\end{wrapfigure} 
#+END_EXPORT

*** Processadores(p)

Agora basta analisar o comportamento do algoritmo BMHS paralelo com o crescimento do número de processadores. Primeiro é importante definir alguns termos para ser feito a avaliação. O primeiro deles é o speedup que é igual a $S=\frac{\text{Tempo do algoritmo sequencial usando 1 processador}}{\text{Tempo do algoritmo paralelo usando p processadores}}$, o próximo termo é a eficiência que será igual a $E=\frac{S}{p}$, sendo p o número de processadores como já definido.

A figura ref:fig:pxtime mostra que de acordo com o aumento do número de processadores há um decaimento no tempo linearmente. Esse é o comportamento esperado que comprova o termo $p$ na complexidade de tempo do algoritmo BMHS paralelo. 

Após isso basta avaliar o speedup obtido com a implementação feita. A figura ref:fig:mxspeedup mostra o speedup na base $\iota$ com 4 processadores, esse speedup não foi perfeito porém esta bem próximo, na média sendo $S_{4}\approx 3.18$, porém é importante notar que na figura os valores de m pequenos tiveram um speedup menor, já para grandes valores de m o algoritmo se estabilizou numa média um pouco melhor. Porém já para 2 processadores, como mostra na figura ref:fig:mxspeedup2p, o speedup é na média $S_{2}\approx 1.78$.

A figura ref:fig:nxspeedup mostra o speedup de acordo com a base usada. Os resultados obtidos foram parecidos com a variação de $m$ na base $\iota$.

Então de acordo com os dados obtidos a eficiência é $E_{4}\approx 0.795$ para 4 processadores e para 2 processadores é $E_{2}\approx 0.89$. A eficiência é significativamente maior com 2 processadores como pode ser observado.

Outro fator importante que pode impactar o desempenho do algoritmo é o número de comparações que existe de diferença entre o BMHS paralelo e BMHS serial. A figura ref:fig:mxcompparalelo mostra que na média o BMHS paralelo tem aproximadamente 24 comparações a mais que o BMHS serial, esse valor é extremamente baixo visto que a média é de até um m igual a 5000. Logo esse valor mostra que o BMHS paralelo não sofre tantas consequências pela sua divisão de blocos. Também é importante notar que existe um crescimento do módulo do número de comparações junto com o crescimento de $m$.

#+begin_export latex
\begin{wrapfigure}{R}{4.5cm}
\caption{Tempo de acordo com número de processadores.}\label{fig:pxtime}
\includegraphics[width=4.5cm]{pxtime}
\end{wrapfigure} 
\begin{wrapfigure}{R}{5.5cm}
\end{wrapfigure}
\begin{wrapfigure}{R}{5.5cm}
\caption{Diferença de comparações BMHS serial e paralelo, base $\iota$.}\label{fig:mxcompparalelo}
\includegraphics[width=5.5cm]{mxcompparalelo}
\end{wrapfigure}
#+end_export

#+begin_export latex
\begin{center}
\begin{figure}
\begin{subfigure}[b]{.33\linewidth}
\centering
\includegraphics[width=5.5cm]{mxspeedup}
\caption{base=$\iota$,p=4}\label{fig:mxspeedup}
\end{subfigure}
\begin{subfigure}[b]{.33\linewidth}
\centering
\includegraphics[width=5.5cm]{nxspeedup}
\caption{m=30,p=4.}\label{fig:nxspeedup}
\end{subfigure}
\begin{subfigure}[b]{.33\linewidth}
\centering
\caption{p=2,base $\iota$.}\label{fig:mxspeedup2p}
\includegraphics[width=5.5cm]{mxspeedup2p}
\end{subfigure}
\caption{Speedup.}
\end{figure}
\end{center}
#+end_export

#+BEGIN_SRC R :results output graphics :file mxtimenoboundworst.jpg :exports none :res 300 :width 5.5 :height 5 :units in
    require(ggplot2)
    require(ggpmisc)
    Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
    names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro","Comparacoes")


    Data$n[Data$n == 50949113]="ι"
    Data$n[Data$n == 101540352]="κ"
    Data$n[Data$n == 156699065]="λ"
    Data$n[Data$n == 204854690]="μ"
    Data$n[Data$n == "1000000"]="A"
    Data<- subset(Data,n=="A")

    Data<- subset(Data,Erro==0|(Implementacao=="m" & Erro=="2"))
    Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))
  Data$TempoTotal[Data$Threads>0]=Data$TempoTotal[Data$Threads>0]/Data$Threads[Data$Threads>0]

    Data$Implementacao[Data$Implementacao == "h"]<-"BMH"
    Data$Implementacao[Data$Implementacao == "s"]="BMHS"
    Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
    Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
    Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"

    qplot(x=m,xlab="m",y=TempoTotal,ylab="Tempo(s)",data=Data,color=Implementacao)+geom_line()+geom_smooth(method= "lm", se = F, formula=y ~ poly(x, 1, raw=TRUE))+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+labs(color="")
#+END_SRC

#+RESULTS:
[[file:mxtimenoboundworst.jpg]]


#+BEGIN_SRC R :results output graphics :file mxtimewordboundworst.jpg :exports none :res 300 :width 5.5 :height 5 :units in
  require(ggplot2)
  require(ggpmisc)
  Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro","Comparacoes")


  Data$n[Data$n == 50949113]="ι"
  Data$n[Data$n == 101540352]="κ"
  Data$n[Data$n == 156699065]="λ"
  Data$n[Data$n == 204854690]="μ"
  Data$n[Data$n == "1000000"]="A"
  Data<- subset(Data,n=="A")

  Data<- subset(Data,m<=64)
  Data<- subset(Data,Erro==0|(Implementacao=="m" & Erro=="2"))
  Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))


Data$TempoTotal[Data$Threads>0]=Data$TempoTotal[Data$Threads>0]/Data$Threads[Data$Threads>0]

  Data$Implementacao[Data$Implementacao == "h"]<-"BMH"
  Data$Implementacao[Data$Implementacao == "s"]="BMHS"
  Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
  Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
  Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"

  qplot(x=m,xlab="m",y=TempoTotal,ylab="Tempo(s)",data=Data,color=Implementacao)+geom_line()+geom_smooth(method= "lm", se = F, formula=y ~ poly(x, 1, raw=TRUE))+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+labs(color="")
#+END_SRC

#+RESULTS:
[[file:mxtimewordboundworst.jpg]]


#+BEGIN_SRC R :results output graphics :file mxtimewordbound.jpg :exports none :res 300 :width 5.5 :height 5 :units in
  require(ggplot2)
  require(ggpmisc)
  Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro")


  Data$n[Data$n == 50949113]="ι"
  Data$n[Data$n == 101540352]="κ"
  Data$n[Data$n == 156699065]="λ"
  Data$n[Data$n == 204854690]="μ"
  Data<- subset(Data,n=="ι")
  Data<- subset(Data,m<=64)
  Data<- subset(Data,Erro==0|(Implementacao=="m" & Erro=="2"))
  Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))
  Data$TempoTotal[Data$Implementacao == "p"]=Data$TempoReal[Data$Implementacao == "p"]
  Data<-aggregate(Data[,4:5],list(Data$Implementacao,Data$n,Data$m),mean)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal")

  Data$Implementacao[Data$Implementacao == "h"]<-"BMH"
  Data$Implementacao[Data$Implementacao == "s"]="BMHS"
  Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
  Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
  Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"

  qplot(x=m,xlab="m",y=TempoTotal,ylab="Tempo(s)",data=Data,color=Implementacao)+geom_line()+labs(color="")
#+END_SRC

#+RESULTS:
[[file:mxtimewordbound.jpg]]

#+BEGIN_SRC R :results output graphics :file mxtimenobound.jpg :exports none :res 300 :width 5.5 :height 5 :units in
    require(ggplot2)
    require(ggpmisc)
    Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
    names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro","Comparacoes")


    Data$n[Data$n == 50949113]="ι"
    Data$n[Data$n == 101540352]="κ"
    Data$n[Data$n == 156699065]="λ"
    Data$n[Data$n == 204854690]="μ"

    Data<- subset(Data,Comparacoes==0)
    Data<- subset(Data,n=="ι")
    Data<- subset(Data,Erro==0|(Implementacao=="m" & Erro=="2"))
    Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))
    Data$TempoTotal[Data$Implementacao == "p"]=Data$TempoReal[Data$Implementacao == "p"]
    Data<-aggregate(Data[,4:5],list(Data$Implementacao,Data$n,Data$m),mean)
    names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal")

    Data$Implementacao[Data$Implementacao == "h"]<-"BMH"
    Data$Implementacao[Data$Implementacao == "s"]="BMHS"
    Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
    Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
    Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"

  Data<- subset(Data,m%%25==0)
    qplot(x=m,xlab="m",y=TempoTotal,ylab="Tempo(s)",data=Data,color=Implementacao)+geom_line()+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+geom_smooth(method= "lm", se = F, formula=y ~ poly(x, 1, raw=TRUE))+labs(color="")

#+END_SRC

#+RESULTS:
[[file:mxtimenobound.jpg]]


#+BEGIN_SRC R :results output graphics :file mxtimenoboundb.jpg :exports none :res 300 :width 5.5 :height 5 :units in
  require(ggplot2)
  require(ggpmisc)
  Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro","Comparacoes")


  Data$n[Data$n == 50949113]="ι"
  Data$n[Data$n == 101540352]="κ"
  Data$n[Data$n == 156699065]="λ"
  Data$n[Data$n == 204854690]="μ"

  Data<- subset(Data,Implementacao=="h"|Implementacao=="s"|Implementacao=="p")
  Data<- subset(Data,Comparacoes==0)
  Data<- subset(Data,n=="ι")
  Data<- subset(Data,Erro==0|(Implementacao=="m" & Erro=="2"))
  Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))
  Data$TempoTotal[Data$Implementacao == "p"]=Data$TempoReal[Data$Implementacao == "p"]
  Data<-aggregate(Data[,4:5],list(Data$Implementacao,Data$n,Data$m),mean)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal")

  Data<- subset(Data,m%%25==0)
  Data$Implementacao[Data$Implementacao == "h"]="BMH"
  Data$Implementacao[Data$Implementacao == "s"]="BMHS"
  Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
  Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
  Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"


  qplot(x=m,xlab="m",y=TempoTotal,ylab="Tempo(s)",data=Data,color=Implementacao)+geom_line()+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+geom_smooth(method= "lm", se = F, formula=y ~ poly(x, 1, raw=TRUE))+labs(color="")

#+END_SRC

#+RESULTS:
[[file:mxtimenoboundb.jpg]]



#+BEGIN_SRC R :results output graphics :file nxtime.jpg :exports none :res 300 :width 5.5 :height 5 :units in
    require(ggplot2)
    require(ggpmisc)
    library(dplyr)
    Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
    names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro","Comparacoes")


    ## Data$n[Data$n == 50949113]="ι"
    ## Data$n[Data$n == 101540352]="κ"
    ## Data$n[Data$n == 156699065]="λ"
    ## Data$n[Data$n == 204854690]="μ"
    Data<- subset(Data,m=="30")
  Data<- subset(Data,Comparacoes>0)
  Data<- subset(Data,n!=1000000)

    Data<- subset(Data,Erro==0|(Implementacao=="m" & Erro=="2"))
    Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))
    Data$TempoTotal[Data$Implementacao == "p"]=Data$TempoReal[Data$Implementacao == "p"]

    Data$Implementacao[Data$Implementacao == "h"]="BMH"
    Data$Implementacao[Data$Implementacao == "s"]="BMHS"
    Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
    Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
    Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"

    Data<-aggregate(Data[,4:5],list(Data$Implementacao,Data$n),mean)
  names(Data) <- c("Implementacao","n","TempoTotal","TempoReal")
    ## summarise(group_by(Data, Implementacao,n), sum(TempoTotal), mean(TempoTotal))
    qplot(x=n,xlab="n",y=TempoTotal,ylab="Tempo(s)",data=Data,color=Implementacao)+geom_line()+geom_smooth(method= "lm", se = F, formula=y ~ poly(x, 1, raw=TRUE))+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+labs(color="")
#+END_SRC

#+RESULTS:
[[file:nxtime.jpg]]

#+BEGIN_SRC R :results output graphics :file nxcomp.jpg :exports none :res 300 :width 5.5 :height 5 :units in
    require(ggplot2)
    require(ggpmisc)
    library(dplyr)
    Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
    names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro","Comparacoes")


    ## Data$n[Data$n == 50949113]="ι"
    ## Data$n[Data$n == 101540352]="κ"
    ## Data$n[Data$n == 156699065]="λ"
    ## Data$n[Data$n == 204854690]="μ"
    Data<- subset(Data,m=="30")
  Data<- subset(Data,Comparacoes>0)
  Data<- subset(Data,n!=1000000)
    Data<- subset(Data,Erro==0|(Implementacao=="m" & Erro=="2"))
    Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))
    Data$TempoTotal[Data$Implementacao == "p"]=Data$TempoReal[Data$Implementacao == "p"]

    Data$Implementacao[Data$Implementacao == "h"]="BMH"
    Data$Implementacao[Data$Implementacao == "s"]="BMHS"
    Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
    Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
    Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"

    Data<-aggregate(Data[,4:5],list(Data$Implementacao,Data$n,Data$Comparacoes),mean)

  names(Data) <- c("Implementacao","n","Comparacoes","TempoTotal","TempoReal")
    ## summarise(group_by(Data, Implementacao,n), sum(TempoTotal), mean(TempoTotal))
    qplot(x=n,xlab="n",y=Comparacoes,ylab="Comparações",data=Data,color=Implementacao)+geom_line()+geom_smooth(method= "lm", se = F, formula=y ~ poly(x, 1, raw=TRUE))+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+labs(color="")

#+END_SRC

#+RESULTS:
[[file:nxcomp.jpg]]

#+BEGIN_SRC R :results output graphics :file errorxtime.jpg :exports none :res 300 :width 5.5 :height 5 :units in
  require(ggplot2)
  require(ggpmisc)
  library(dplyr)
  Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro","Comparacoes")

  Data$n[Data$n == 50949113]="ι"
  Data$n[Data$n == 101540352]="κ"
  Data$n[Data$n == 156699065]="λ"
  Data$n[Data$n == 204854690]="μ"
  Data<- subset(Data,n=="ι")
  Data<- subset(Data,m=="30")
  Data<- subset(Data,Implementacao=="m")

  summarise(group_by(Data, Implementacao,n), sum(TempoTotal), mean(TempoTotal))
  qplot(x=Erro,xlab="Erro",y=TempoTotal,ylab="Tempo(s)",data=Data)+geom_point()+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+geom_smooth(method= "lm", se = F, formula=y ~ poly(x, 1, raw=TRUE))+labs(color="")

#+END_SRC

#+RESULTS:
[[file:errorxtime.jpg]]

#+BEGIN_SRC R :results output graphics :file pxtime.jpg :exports none :res 300 :width 5.5 :height 5 :units in
  require(ggplot2)
  require(ggpmisc)
  Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro")


  Data$n[Data$n == 50949113]="ι"
  Data$n[Data$n == 101540352]="κ"
  Data$n[Data$n == 156699065]="λ"
  Data$n[Data$n == 204854690]="μ"
  Data<- subset(Data,n=="ι")
  Data<- subset(Data,m=="30")
  Data<- subset(Data,Implementacao=="p")
   Data$TempoTotal[Data$Implementacao == "p"]=Data$TempoReal[Data$Implementacao == "p"]

  aggregate(Data[,4:5],list(Data$Threads),mean)
  qplot(x=Threads,xlab="Processadores",y=TempoTotal,ylab="Tempo(s)",data=Data)+geom_point()+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+ geom_smooth(method= "lm", se = F, formula=y ~ poly(x, 1, raw=TRUE))+labs(color="")

#+END_SRC

#+RESULTS:
[[file:pxtime.jpg]]

#+BEGIN_SRC R :results output graphics :file mxspeedup.jpg :exports none :res 300 :width 5.5 :height 5 :units in
  require(ggplot2)
  require(ggpmisc)


  Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro")


  Data$n[Data$n == 50949113]="ι"
  Data$n[Data$n == 101540352]="κ"
  Data$n[Data$n == 156699065]="λ"
  Data$n[Data$n == 204854690]="μ"
  Data<- subset(Data,n=="ι")
  Data<- subset(Data,Implementacao=="s"| (Implementacao=="p" & Threads=="4"))
  Data$TempoTotal[Data$Threads>0]=Data$TempoTotal[Data$Threads>0]/Data$Threads[Data$Threads>0]
  ## Data$TempoTotal[Data$Implementacao == "p"]=Data$TempoReal[Data$Implementacao == "p"]
  Data<- subset(Data,Threads==0|(Implementacao=="p" & Threads=="4"))
  Data = aggregate(Data[,4:5],list(Data$Implementacao,Data$n,Data$m),mean)
  d2<- subset(Data,Group.1=="s")

  d1<- subset(Data,(Group.1=="p"))
  d1$SpeedUp<- d2$TempoTotal/d1$TempoTotal

  d1$Group.1[d1$Group.1 == "p"]="BMHS Paralelo"
  a=paste("Média:",mean(d1$SpeedUp))
  qplot(x=Group.3,xlab="m",y=SpeedUp,ylab="SpeedUp",data=d1,color=Group.1)+geom_line()+stat_function(fun=function(x) 4, geom="line", aes(colour="Perfeito"))+labs(color="")+geom_hline(yintercept = mean(d1$SpeedUp), color="red")+annotate("text",x=-Inf,y=-Inf,hjust=0,vjust=0,label=a)
#+END_SRC

#+RESULTS:
[[file:mxspeedup.jpg]]

#+BEGIN_SRC R :results output graphics :file nxspeedup.jpg :exports none :res 300 :width 5.5 :height 5 :units in
  require(ggplot2)
  require(ggpmisc)


  Data <- read.table("../data/data.txt",stringsAsFactors = FALSE)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro","Comparacoes")

  Data<- subset(Data,Comparacoes==0)
  Data<- subset(Data,m==30)
  Data<- subset(Data,Implementacao=="s"| (Implementacao=="p" & Threads=="4"))
  Data$TempoTotal[Data$Threads>0]=Data$TempoTotal[Data$Threads>0]/Data$Threads[Data$Threads>0]
  ## Data$TempoTotal[Data$Implementacao == "p"]=Data$TempoReal[Data$Implementacao == "p"]
  Data<- subset(Data,Threads==0|(Implementacao=="p" & Threads=="4"))
  Data = aggregate(Data[,4:5],list(Data$Implementacao,Data$n,Data$m),mean)
  d2<- subset(Data,Group.1=="s")

  d1<- subset(Data,(Group.1=="p"))
  d1$SpeedUp<- d2$TempoTotal/d1$TempoTotal

  d1$Group.1[d1$Group.1 == "p"]="BMHS Paralelo"
  a=paste("Média:",mean(d1$SpeedUp))

  qplot(x=Group.2,xlab="n",y=SpeedUp,ylab="SpeedUp",data=d1,color=Group.1)+geom_line()+stat_function(fun=function(x) 4, geom="line", aes(colour="Perfeito"))+labs(color="")+geom_hline(yintercept = mean(d1$SpeedUp), color="red")+annotate("text",x=-Inf,y=-Inf,hjust=0,vjust=0,label=a)
#+END_SRC

#+RESULTS:
[[file:nxspeedup.jpg]]

#+BEGIN_SRC R :results output graphics :file mxcompparalelo.jpg :exports none :res 300 :width 5.5 :height 5 :units in
require(ggplot2)
require(ggpmisc)

Data <- read.table("../data/data2.txt",stringsAsFactors = FALSE)
names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro","Comparacoes")

Data<- subset(Data,Comparacoes>0)
Data<- subset(Data,Implementacao=="s"| (Implementacao=="p" & Threads=="4"))
Data$TempoTotal[Data$Threads>0]=Data$TempoTotal[Data$Threads>0]/Data$Threads[Data$Threads>0]
Data<- subset(Data,Threads==0|(Implementacao=="p" & Threads=="4"))

d1<- subset(Data,Implementacao=="p")
d2<- subset(Data,Implementacao=="s")
d1$ComAMais<- d1$Comparacoes-d2$Comparacoes

a=paste("Média:",mean(d1$ComAMais))
qplot(x=m,xlab="m",y=ComAMais,ylab="Comparações a mais",data=d1)+geom_line()+geom_hline(yintercept = mean(d1$ComAMais), color="red")+annotate("text",x=-Inf,y=-Inf,hjust=0,vjust=0,label=a)

#+END_SRC

#+RESULTS:
[[file:mxcompparalelo.jpg]]

#+BEGIN_SRC R :results output graphics :file mxspeedup2p.jpg :exports none :res 300 :width 5.5 :height 5 :units in
  require(ggplot2)
  require(ggpmisc)


  Data <- read.table("../data/data3.txt",stringsAsFactors = FALSE)
  names(Data) <- c("Implementacao","n","m","TempoTotal","TempoReal","Threads","Erro")


  Data$n[Data$n == 50949113]="ι"
  Data$n[Data$n == 101540352]="κ"
  Data$n[Data$n == 156699065]="λ"
  Data$n[Data$n == 204854690]="μ"
  Data<- subset(Data,n=="ι")
  Data<- subset(Data,Implementacao=="s"| (Implementacao=="p" & Threads=="2"))
  Data$TempoTotal[Data$Threads>0]=Data$TempoTotal[Data$Threads>0]/Data$Threads[Data$Threads>0]
  ## Data$TempoTotal[Data$Implementacao == "p"]=Data$TempoReal[Data$Implementacao == "p"]
  Data<- subset(Data,Threads==0|(Implementacao=="p" & Threads=="2"))
  Data = aggregate(Data[,4:5],list(Data$Implementacao,Data$n,Data$m),mean)
  d2<- subset(Data,Group.1=="s")

  d1<- subset(Data,(Group.1=="p"))
  d1$SpeedUp<- d2$TempoTotal/d1$TempoTotal

  d1$Group.1[d1$Group.1 == "p"]="BMHS Paralelo"
  a=paste("Média:",mean(d1$SpeedUp))
  qplot(x=Group.3,xlab="m",y=SpeedUp,ylab="SpeedUp",data=d1,color=Group.1)+geom_line()+stat_function(fun=function(x) 2, geom="line", aes(colour="Perfeito"))+labs(color="")+geom_hline(yintercept = mean(d1$SpeedUp), color="red")+annotate("text",x=-Inf,y=-Inf,hjust=0,vjust=0,label=a)
#+END_SRC

#+RESULTS:
[[file:mxspeedup2p.jpg]]


** Espaço

   Para provar a complexidade de espaço do algoritmo principal basta monitorar as alocações feitas pelo algoritmo para cada tamanho de entrada. O monitoramento será feito somente da memória /heap/ cite:osthreeeasypieces que é a parte da memória onde a alocação dinâmica é feita e o espaço pode-se variar dinamicamente permitindo-se assim obter uma função de complexidade correta.
   
Na figura ref:fig:mxbytes é comprovado que $m$ influência na complexidade de espaço dos algoritmos. Também é possível ver o salto que há no uso de memoria do ShiftAnd de acordo com que é necessário alocar blocos de $\beta$ bits. É possivel observar que o BMH, BMHS e BMHS Paralelo compartilham da mesma função de uso de bytes, isso se deve a eles usarem somente o espaço de alocar o padrão no programa principal.

A figura ref:fig:nxbytes mostra também que todos algoritmos somente alocam o texto no programa principal, por isso todos possuem a mesma função em relação a variável n.

As figuras ref:fig:errorxbytes e ref:fig:pxbytes comprovam o fator de erro e de número de processadores na complexidade de espaço dos algoritmos ShiftAnd e BMHS paralelo respectivamente.

#+begin_export latex
\begin{center}
\begin{figure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\caption{base=$\zeta$.}\label{fig:mxbytes}
\includegraphics[width=4.4cm]{mxbytes}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\caption{m=30.}\label{fig:nxbytes}
\includegraphics[width=4.4cm]{nxbytes}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\caption{base=$\zeta$,m=30.}\label{fig:errorxbytes}
\includegraphics[width=3.5cm]{errorxbytes}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\caption{base=$\zeta$,m=30.}\label{fig:pxbytes}
\includegraphics[width=3.5cm]{pxbytes}
\end{subfigure}
\caption{Espaço utilizado pelos algoritmos em termos de diversos fatores.}
\end{figure}
\end{center}
#+end_export


   #+BEGIN_SRC R :results output graphics :file mxbytes.jpg :exports none :res 300 :width 5.5 :height 5 :units in
     require(ggplot2)
     require(ggpmisc)

     Data <- read.table("../data/mem.txt",stringsAsFactors = FALSE)
     names(Data) <- c("Implementacao","n","m","bytes","Threads","Erro")

     Data$n[Data$n == 1080685]="ζ"
     Data$n[Data$n == 3402262]="η"
     Data$n[Data$n == 5198187]="θ"
     Data$n[Data$n == 50949113]="ι"
     Data$n[Data$n == 101540352]="κ"
     Data$n[Data$n == 156699065]="λ"
     Data$n[Data$n == 204854690]="μ"

     Data<- subset(Data,n=="ζ")
     Data<- subset(Data,Erro==0|(Implementacao=="m" & Erro=="2"))
     Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))

     Data$Implementacao[Data$Implementacao == "h"]<-"BMH"
     Data$Implementacao[Data$Implementacao == "s"]="BMHS"
     Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
     Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
     Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"
     qplot(x=m,xlab="m",y=bytes,ylab="Bytes",data=Data,color=Implementacao)+geom_line()+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+geom_smooth(method= "lm", se = F, formula=y ~ poly(x, 1, raw=TRUE))+labs(color="")

   #+END_SRC

   #+RESULTS:
   [[file:mxbytes.jpg]]


   #+BEGIN_SRC R :results output graphics :file nxbytes.jpg :exports none :res 300 :width 5.5 :height 5 :units in
require(ggplot2)
require(ggpmisc)

Data <- read.table("../data/mem.txt",stringsAsFactors = FALSE)
names(Data) <- c("Implementacao","n","m","bytes","Threads","Erro")

Data<- subset(Data,m==30)
Data<- subset(Data,Erro==0|(Implementacao=="m" & Erro=="2"))
Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))

Data$Implementacao[Data$Implementacao == "h"]<-"BMH"
Data$Implementacao[Data$Implementacao == "s"]="BMHS"
Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"
qplot(x=n,xlab="n",y=bytes,ylab="Bytes",data=Data,color=Implementacao)+geom_line()+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)+labs(color="")

   #+END_SRC

   #+RESULTS:
   [[file:nxbytes.jpg]]


   #+BEGIN_SRC R :results output graphics :file errorxbytes.jpg :exports none :res 300 :width 5.5 :height 5 :units in
require(ggplot2)
require(ggpmisc)

Data <- read.table("../data/mem.txt",stringsAsFactors = FALSE)
names(Data) <- c("Implementacao","n","m","bytes","Threads","Erro")

Data$n[Data$n == 1080685]="ζ"
Data$n[Data$n == 3402262]="η"
Data$n[Data$n == 5198187]="θ"
Data$n[Data$n == 50949113]="ι"
Data$n[Data$n == 101540352]="κ"
Data$n[Data$n == 156699065]="λ"
Data$n[Data$n == 204854690]="μ"

Data<- subset(Data,n=="ζ")
Data<- subset(Data,m==30)
Data<- subset(Data,Implementacao=="m")
## Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))

Data$Implementacao[Data$Implementacao == "h"]<-"BMH"
Data$Implementacao[Data$Implementacao == "s"]="BMHS"
Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"
qplot(x=Erro,xlab="Erro",y=bytes,ylab="Bytes",data=Data)+geom_line()+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)
   #+END_SRC

   #+RESULTS:
   [[file:errorxbytes.jpg]]


   #+BEGIN_SRC R :results output graphics :file pxbytes.jpg :exports none :res 300 :width 5.5 :height 5 :units in
require(ggplot2)
require(ggpmisc)

Data <- read.table("../data/mem.txt",stringsAsFactors = FALSE)
names(Data) <- c("Implementacao","n","m","bytes","Threads","Erro")

Data$n[Data$n == 1080685]="ζ"
Data$n[Data$n == 3402262]="η"
Data$n[Data$n == 5198187]="θ"
Data$n[Data$n == 50949113]="ι"
Data$n[Data$n == 101540352]="κ"
Data$n[Data$n == 156699065]="λ"
Data$n[Data$n == 204854690]="μ"

Data<- subset(Data,n=="ζ")
Data<- subset(Data,m==30)
Data<- subset(Data,Implementacao=="p")
## Data<- subset(Data,Threads==0| (Implementacao=="p" & Threads=="4"))

Data$Implementacao[Data$Implementacao == "h"]<-"BMH"
Data$Implementacao[Data$Implementacao == "s"]="BMHS"
Data$Implementacao[Data$Implementacao == "n"]="Shift-And Exato"
Data$Implementacao[Data$Implementacao == "p"]="BMHS Paralelo"
Data$Implementacao[Data$Implementacao == "m"]="Shift-And Aproximado"
qplot(x=Threads,xlab="Processadores",y=bytes,ylab="Bytes",data=Data)+geom_line()+stat_poly_eq(formula=y~poly(x,1), aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), parse = TRUE)
   #+END_SRC

   #+RESULTS:
   [[file:pxbytes.jpg]]

** Análise geral

   Com os algoritmos analisados e mostrados suas eficiências na prática pode-se criar uma hierarquia dos mesmos para cada situação. Veja a figura ref:fig:hierarquia.

Para casos médios o BMHS Paralelo foi o mais rápido dentre todos, porém se for o pior caso esse algoritmo não é tão bom assim porém não é o pior de todos algoritmos.

Em casos médios o BMH é um bom algoritmo, porém não há muitas diferenças dele para o BMHS, em relação a desempenho, somente em casos específicos um supera o outro.

Já o ShiftAnd quando no pior caso ele é consideravelmente mais rápido que os outros algoritmos pois sua complexidade não depende do padrão, porém em casos médios esse algoritmo é extremamente lento comparado aos outros, ainda mais se for Shift-And aproximado.

   # O BMHS Paralelo foi o mais rapido para m pequeno, porém se m for grande havera muitos blocos redudantes o que pode impactar no desempenho

#+begin_export latex
\begin{center}
\begin{figure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\caption{Caso médio empírico.}
\begin{tikzpicture}
\node[draw,rectangle,minimum width = 3.5cm] (n1) {BMHS Paralelo};
\node[draw,rectangle,minimum width = 3.5cm,yshift=-0.5cm] (n2) {BMHS};
\node[draw,rectangle,minimum width = 3.5cm,yshift=-1cm] (n3) {BMH};
\node[draw,rectangle,minimum width = 3.5cm,yshift=-1.55cm] (n4) {Shift-And};
\draw[<-,line width=0.3mm,right of = n1,xshift=1cm,yshift=0.27cm] (0,0) -- (0,-2.1) node[anchor=south west] {Rapidez};
\end{tikzpicture}
\end{subfigure}
\begin{subfigure}[b]{.49\linewidth}
\centering
\caption{Pior caso empírico.}
\begin{tikzpicture}
\node[draw,rectangle,minimum width = 3.5cm] (n1) {Shift-And};
\node[draw,rectangle,minimum width = 3.5cm,yshift=-0.5cm] (n2) {BMHS Paralelo};
\node[draw,rectangle,minimum width = 3.5cm,yshift=-1cm] (n3) {BMHS};
\node[draw,rectangle,minimum width = 3.5cm,yshift=-1.55cm] (n4) {BMH};
\draw[<-,line width=0.3mm,right of = n1,xshift=1cm,yshift=0.27cm] (0,0) -- (0,-2.1) node[anchor=south west] {Rapidez};
\end{tikzpicture}
\end{subfigure}
\caption{Hierarquia de tempo empírico.}\label{fig:hierarquia}
\end{figure}
\end{center}
#+end_export

* Conclusão

Com esse trabalho foi possível estudar a complexidade e o funcionamento dos algoritmos BMH,BMHS,Shift-And,Shift-And aproximado, BMHS paralelizado. Foi possível ver que o BMH e BMHS com complexidades piores que o Shift-And ainda sim conseguem na prática ser melhor que o Shift-And. A complexidade esperada de $O(n/m)$ do algoritmo BMH e BMHS também foram vistas na prática e suas superioridades em relação ao Shift-And.

Os algoritmos foram classificados baseados nos desempenhos dos resultados, sendo o BMHS Paralelo o melhor algoritmo para casos médios e o Shift-And o melhor algoritmo para o pior caso.

Uma distribuição de blocos de memória foi modelada para o algoritmo BMHS Paralelo essa distribuição de blocos foi analisada de diversas formas, criando diversas funções que descrevem suas características, exemplo: seu tamanho total de blocos, taxa de blocos redundantes e etc. O BMHS paralelo obteve um speedup bom, sendo ele $S_{4}\approx 3.18$ com 4 processadores e $S_{2}\approx 1.78$ com 2 processadores.

Os algoritmos foram aplicados em genomas e esse estudo pode ser utilizado em outros trabalhos que aplique os algoritmos a outras áreas e as comparem.

Em futuros trabalhos pode-se estudar os efeitos da busca em arquivos comprimidos e todos seus impactos profundamente através dessa base que foi estudada nesse trabalho.

  bibliographystyle:plain
  bibliography:doc.bib
